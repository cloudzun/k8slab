实战演练

ver 1.0 基本构建
ver 2.0 为后端配置数据持久化 (需要参照storage章节配置好nfs和csi以及storageclass)
ver 3.0 为后端配置ConfigMap和Secret
ver 4.0 为前端配置ingress （需要参照svc章节配置好ingress）
ver 5.0 为前段配置横向扩缩容（需要参照perfmon章节启用metric server）
ver 6.0 配置监控

ver 1.0 基本构建

创建命名空间：

kubectl create ns blog

创建基本mysql Deployment

nano mysql.deploy.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-deploy
  namespace: blog
  labels:
    app: mysql
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:5.7
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 3306
          name: dbport
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: wordpress
        - name: MYSQL_DATABASE
          value: wordpress

kubectl apply -f mysql.deploy.yaml

创建mysql服务
nano mysql.svc.yaml

apiVersion: v1
kind: Service
metadata:
  name: mysql
  namespace: blog
spec:
  selector:
    app: mysql
  ports:
  - name: mysqlport
    protocol: TCP
    port : 3306
    targetPort: 3306

kubectl apply -f mysql.svc.yaml

创建基本wordpress deployment
nano wordpress.deploy.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress-deploy
  namespace: blog
  labels:
    app: wordpress
spec:
  replicas: 1
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:php7.4
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 80
          name: wdport
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql.blog.svc.cluster.local:3306 #此处是mysql svc的域名，且可以忽略3306端口号
        - name: WORDPRESS_DB_USER
          value: root
        - name: WORDPRESS_DB_PASSWORD
          value: wordpress
        - name: WORDPRESS_DB_NAME
          value: wordpress

kubectl apply -f wordpress.deploy.yaml 

创建wordpress-svc
nano wordpress.svc.yaml

apiVersion: v1
kind: Service
metadata:
 name: wordpress-svc
 namespace: blog
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
  selector:
    app: wordpress
  type: ClusterIP
  
kubectl apply -f wordpress.svc.yaml 

创建wordpress-nodeport
nano wordpress.svc2.yaml

apiVersion: v1
kind: Service
metadata:
 name: wordpress-nodeport
 namespace: blog
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
    nodePort: 30180 # 使用nodeport 30180
  selector:
    app: wordpress
  type: NodePort

kubectl apply -f wordpress.svc2.yaml 

查看blog命名空间下的pod和svc,查看对象是否都创建成功

kubectl get pod -n blog

kubectl get svc -n blog

随后使用 http://nodepubicip:30180 进行访问，


ver 2.0 为后端配置数据持久化

定义mysql pvc文件
nano mysql.pvc.yaml 

kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: mysqldata
  namespace: blog
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: nfs-csi # 指定使用存储类
  resources:
    requests:
      storage: 5Gi

更新PVC
kubectl apply -f mysql.pvc.yaml

查看pvc
kubectl get pvc -n blog -o wide
  *可以看到系统自动创建了pv

查看pv
kubectl get pv -o wide
  
查看pv详细信息
kubectl describe pv pvc-0ea6bcbf-a977-4451-bada-0358f1ae32d3 -n blog
  *重点关注pv所对应路径

在NFS节点上查看pv所对应的目录
ll /data/pvc-0ea6bcbf-a977-4451-bada-0358f1ae32d3/
  *此时应该是空的

更新mysql deployment

nano mysql.deploy2.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-deploy
  namespace: blog
  labels:
    app: mysql
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      volumes: # 定义卷
      - name: mysqldata
        persistentVolumeClaim: # 使用PVC
          claimName: mysqldata
      containers:
      - name: mysql
        image: mysql:5.7
        imagePullPolicy: IfNotPresent
        volumeMounts:    #设定挂接点
        - name: mysqldata
          mountPath: /var/lib/mysql
        ports:
        - containerPort: 3306
          name: dbport
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: wordpress
        - name: MYSQL_DATABASE
          value: wordpress

更新mysql
kubectl apply -f mysql.deploy2.yaml 

再次查看pv所对应的目录
ll /data/pvc-0ea6bcbf-a977-4451-bada-0358f1ae32d3/
  *此时应该有料

ver 3.0 为后端配置ConfigMap和Secret

使用范例创建配置文件
nano mysqld.cnf

[mysqld]
pid-file  = /var/run/mysqld/mysqld.pid
socket    = /var/run/mysqld/mysqld.sock
datadir   = /var/lib/mysql
symbolic-links=0
port    = 3306

创建mysql配置文件
kubectl create configmap mysql-cnf --from-file=./mysqld.cnf -n blog

查看configmap
kubectl get configmap -n blog

查看configmap详情
kubectl describe configmap mysql-cnf -n blog

kubectl get configmap mysql-cnf -n blog -o yaml

创建secret
kubectl create secret generic mysql-pass --from-literal=password=password -n blog

查看secret
kubectl get secret -n blog

kubectl describe secret mysql-pass -n blog

kubectl get -o yaml secret mysql-pass -n blog
  *找到password对应的值

解码password
echo d29yZHByZXNz | base64 -d

将configmap和secrect更新到mysql.deploy3.yaml
nano mysql.deploy3.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-deploy
  namespace: blog
  labels:
    app: mysql
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      volumes:
      - name: mysql-config # 定义configmap 卷
        configMap:
          name: mysql-cnf
      containers:
      - name: mysql
        image: mysql:5.7
        imagePullPolicy: IfNotPresent
        volumeMounts:
        - name: mysql-config # 挂接configmap卷
          mountPath: /etc/mysql/mysql.conf.d
        ports:
        - containerPort: 3306
          name: dbport
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom: # 从secrect处调用密码
            secretKeyRef:
              name: mysql-pass
              key: password
        - name: MYSQL_DATABASE
          value: wordpress

更新mysql
kubectl apply -f mysql.deploy3.yaml

进入mysql上下文查看env
kubectl exec -it mysql-deploy-6dbc9776b-5z8n5 /bin/bash -n blog

env
 *关注MYSQL_ROOT_PASSWORD=password

查看mysql的配置文件
cat /etc/mysql/mysql.conf.d/mysqld.cnf 

退出pod上下文
exit

将secrect密文更新到wordpress.deploy2.yaml
nano wordpress.deploy2.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress-deploy
  namespace: blog
  labels:
    app: wordpress
spec:
  replicas: 1
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:php7.4
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 80
          name: wdport
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql.blog.svc.cluster.local:3306 #此处是mysql svc的域名，且可以忽略3306端口号
        - name: WORDPRESS_DB_USER
          value: root
        - name: WORDPRESS_DB_PASSWORD
          valueFrom: # 从secrect处调用密码
            secretKeyRef:
              name: mysql-pass
              key: password
        - name: WORDPRESS_DB_NAME
          value: wordpress

kubectl apply -f wordpress.deploy2.yaml


ver 4.0 为前端配置ingress

使用以下范例创建ingress配置
nano wordpress.ingress.yaml

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: wordpress-ingress
  namespace: blog
  annotations:
    kubernetes.io/ingress.class: nginx
spec:
  rules:
  - host: wordpress.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: wordpress-svc
            port:
              number: 80


启用ingress
kubectl apply -f wordpress.ingress.yaml 

查看ingress资源，特别关注ADDRESS
kubectl get ingress -n blog -o wide

查看ingress细节
kubectl describe ingress wordpress-ingress -n blog

使用以下命令测试ingress
curl http://192.168.0.36 -H "Host: wordpress.example.com"

亦可修改hosts文件
nano /etc/hosts
 * 192.168.0.36    wordpress.example.com

测试
curl http://wordpress.example.com

尝试在公网上进行解析
 *宿主机的80端口需要开放，如果使用自定义域名，则需要使用ingress-controll所在节点的公网IP做dns解析


ver 5.0 为前段配置横向扩缩容


更新wordpress配置资源使用上下限
nano wordpress.deploy3.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress-deploy
  namespace: blog
  labels:
    app: wordpress
spec:
  replicas: 1
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - name: wordpress
        image: wordpress:php7.4
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 80
          name: wdport
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql.blog.svc.cluster.local:3306 #此处是mysql svc的域名，且可以忽略3306端口号
        - name: WORDPRESS_DB_USER
          value: root
        - name: WORDPRESS_DB_PASSWORD
          valueFrom: # 从secrect处调用密码
            secretKeyRef:
              name: mysql-pass
              key: password
        - name: WORDPRESS_DB_NAME
          value: wordpress
        resources:
          requests:
            memory: "128Mi"
            cpu: "50m"
          limits:
            memory: "256Mi"
            cpu: "100m"

kubectl apply -f wordpress.deploy3.yaml

手动扩展前端
kubectl scale --replicas=5 deployment/wordpress-deploy -n blog

查看pod
kubectl get pod -n blog -o wide

创建hpa策略
nano wordpress.hpa.yaml

apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  name: wordpress-deploy
  namespace: blog
spec:
  maxReplicas: 10
  minReplicas: 3
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: wordpress-deploy
  targetCPUUtilizationPercentage: 50

kubectl apply -f wordpress.hpa.yaml

查看hpa
kubectl get hpa -n blog 

kubectl get hpa wordpress-deploy -n blog -o yaml

观察pod的缩容
kubectl get pod -n blog | grep wordpress
  *3分钟后，将会缩容到3个pod

观察deployment缩容
kubectl describe deployment wordpress-deploy -n blog


# 也可以使用命令行方式创建hpa策略
# kubectl autoscale deployment wordpress-deploy -n blog --cpu-percent=50 --min=3 --max=10
